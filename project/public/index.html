<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tiles of the Kingdom</title>
  <style>
    body {
  font-family: sans-serif;
  margin: 0; /* Remove margin to prevent shifts */
  display: flex;
  flex-direction: column; /* Keep heading above board */
  align-items: center; /* Center horizontally */
  justify-content: center; /* Center vertically */
  height: 100vh; /* Ensure full height */
}
    html, body {
      font-family: 'BotW';

      overscroll-behavior: none;
      touch-action: none; /* Disables all default touch gestures */
      overflow: hidden;  /* Prevents scrolling */
      height: 100%; /* Ensure full-page coverage */
      height: 100%;
      margin: 0;
      display: flex;
      justify-content: center; /* Center horizontally */
      align-items: center;  /* Center vertically */
    }

#guard {
  position: relative; /* Keeps the board centered even when resizing */

  /* Define minimum margins */
  --min-margin: 50px;

  /* Calculate the max width and height while respecting margins */
  --max-width: calc(100vw - 2 * max(10vw, var(--min-margin)));
  --max-height: calc(100vh - max(10vh, var(--min-margin)));

  /* Adjust the "8/9" ratio for more vertical margin */
  width: calc(min(var(--max-width), calc(var(--max-height) * 8/11)));
  height: calc(min(calc(var(--max-width) * 11/8), var(--max-height)));


  display: flex;
  flex-wrap: wrap;
}
#swipeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999; /* Always in front */
            background-color: rgba(0, 0, 0, 0);
            /* Allows clicks to pass through */
        }
@font-face {
    font-family: 'BotW'; /* This is the name you will use in CSS */
    /*src: url('Fonts/HyliaSerifBeta-Regular.woff2') format('woff2'); */
    src: url('Fonts/HyliaSerifBeta-Regular.woff') format('woff');
    font-weight: normal;
    font-style: normal;
}
.test-text {
            font-size: 36px;
            font-weight: normal;
            color: white;
        }
  </style>
  <link rel="icon" type="image/png" href="Animations/favicon.png">
</head>
<body>
  <div id="guard"></div>
  <div id="board"></div>
  <div id="stack"></div>

  <div id="swipeOverlay"></div>
  
  <script>
    //convention e.g. for tile is that tile contains every relevant property for gameplay.
    //tileGraphic contains x, y, a tile, AND any associated transforms.
    class Tile {
      constructor(type, level, maxHealth) {
        this.type = type;
        this.level = level;
        this.maxHealth = maxHealth; this.health=maxHealth;
        this.thisHit = 0; this.thisCombo = 0; this.thisThreat = 0;
        this.canHoverTick = 0;
        //Refers to the maximum length of an onscreen animation
      }
    }

    class TileGraphic {
      constructor(x, y, tile, size=1) {
        this.x = x; this.y = y; this.tile = tile;
        this.size = size
      }
    }

    class Weapon {
      constructor(type, level) {
        this.type = type;
        this.level = level;
        //Conscious decision not to make this null, null implies lack of object reference.
        //Similar conscious decision not to make this assignable on construction.
        this.selected = false
        this.flash = 0
      }
    }

    class WeaponGraphic {
      constructor(x, y, weapon, size=1, shear=1) {
        this.x = x; this.y = y; this.weapon = weapon;
        this.size=size; this.shear=shear
      }
    }

    class BombGraphic {
      constructor(x, y, frame, type = "Explosion") {this.x = x; this.y = y; this.frame = frame, this.type = type}
    }

    let gameOver = false;

    let animalsToWeapons = { "Bokoblin": "sword", "Moblin": "two handed", "Lizalfo": "spear"}

    let debug = ""
    // Board size
    const size = 4;
    // 2D array representing the grid
    let grid = Array.from({ length: size }, () => Array(size).fill(null));

    let currentAnimal = null
    let currentAnimalRow = -1
    let currentAnimalColumn = -1
    let targetTiles = [[false,false,false,false],[false,false,false,false],[false,false,false,false],[false,false,false,false]]
    //tileStack is a list of lists of tile graphics
    let tileStack = []
    tileStack.push(cookBoard())

    let bombStack = []
    bombStack.push([])
    //bombStack.push([new BombGraphic(0,0,0)])

    let weapons = []

    let weaponStack = []
    let weaponWidth, weaponBuffer
    //Max weapons wieldable at once
    let weaponCap = 10

    let currentWeapon = null
    let currentIndex = -1
    let attackMode = false
  
    weaponStack.push(cookStack())

    //Q stands for cumulative. Presumably, c will stand for combo and h for hit.
    let qKills = 0
    let qKillTurns = 0
    let score = 0
    let appendToScore = 0
    let appendCooldown = 0
    let combo = 0

    let comboSize = 1
    // Initialize the board with two tiles

    const dontGarbageCollect = []

  
    function trueMin(...args) {
      function minUniqueValue(arr) {
        const uniqueValues = [...new Set(arr)]; // Remove duplicates
        return Math.min(...uniqueValues);
      
      }
    if (args.length === 1 && Array.isArray(args[0])) {
        // If a single array is passed, use it directly
        return minUniqueValue(args[0]);
    } else {
        // Otherwise, treat args as multiple number inputs
        return minUniqueValue(args)
      }
    }

    function cacheAnimal(folder) {
      for (let i = 1; i <= 5; i++) {
        cacheFrom(`${folder}${i}/`,1,3)
      }
    }
    function cacheFrom(folder, start, end) {
      for (let i = start; i <= end; i++) {
        cacheOnly(`${folder}${i}.png`)
      }
    }
    function cacheOnly(file) {
      //const img = new Image()
      //img.src = file
      dontGarbageCollect.push(file);
    }
    let tileSize, eighty, eeight, ate, bigScale

    let didWeCache = false

    function cacheEverything() {
      if (!didWeCache) {
        didWeCache = true
        cacheAnimal("Animations/Animals/Bokoblin/")
        cacheAnimal("Animations/Animals/Moblin/")
        cacheAnimal("Animations/Animals/Lizalfo/")
        cacheAnimal("Animations/Animal Masks/Bokoblin/")
        cacheAnimal("Animations/Animal Masks/Moblin/")
        cacheAnimal("Animations/Animal Masks/Lizalfo/")

        cacheFrom("Animations/Hearts/red/",1,20)
        cacheFrom("Animations/Hearts/white/",1,20)

        cacheFrom("Animations/Explosion/",0,37)
        cacheFrom("Animations/TK explosion/",0,38)

        cacheFrom("Animations/Weapons/spear/",0,6)
        cacheFrom("Animations/Weapons/sword/",0,6)
        cacheFrom("Animations/Weapons/two handed/",0,6)

        cacheFrom("Animations/Threat Level/",1,5)
        cacheFrom("Animations/Threat Backing/",1,5)
      }
    }
    function init() {
      cacheEverything()
      function callback() {
          if (localStorage.getItem("highScore") === null){
            localStorage.setItem("highScore",0)
          }
          minimalReset();
          spawnRandomTile();
          spawnRandomTile();
          requestAnimationFrame(gameLoop);
      }
      let loadedCount = 0;
      const images = [];
      dontGarbageCollect.forEach((src, index) => {
          const img = new Image();
          img.src = src;
          img.onload = () => {
              loadedCount++;
              if (loadedCount === dontGarbageCollect.length) {
                  callback();
              }
          };
          img.onerror = () => {
              loadedCount++;
              if (loadedCount === dontGarbageCollect.length) {
                  callback();
              }
          };
          images[index] = img; // Store to prevent garbage collection
      })
      
    }

    let lastFrameTime = 0; let lastDelta = 0;
    
    function gameLoop(currentTime) {
      if (currentTime - lastFrameTime >= 1000/60) {
        lastDelta = currentTime - lastFrameTime
        lastFrameTime = currentTime;
        drawAll();
      }
      requestAnimationFrame(gameLoop);
    }

    
    // Place a new tile (value = 2) in a random empty spot
    function spawnRandomTile() {
      const emptyPositions = [];
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (grid[r][c] === null) {
            emptyPositions.push({ r, c });
          }
        }
      }
      if (emptyPositions.length > 0) {
        const { r, c } = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
        //health is 10 for now
        //health should be 1 + qKills
        grid[r][c] = new Tile (["Bokoblin","Moblin","Lizalfo"][Math.floor(Math.random() * 3)], 1, 1+qKillTurns);
        //Assumes something is actually taking place on screen.
        while (tileStack.length < 20) {
          tileStack.push(tileStack[tileStack.length - 1].slice())
        }
        //Seemingly pushes all ten 
        for (let i = 0; i < 10; i++) {
          tileStack[tileStack.length - 10 + i].push(new TileGraphic(c*eeight,r*eeight,grid[r][c],i/10))
        }
        tileStack.push(cookBoard())
      }
      
    }

    // Reset board and scaling, namely kills the board and gives rise to it in the guard
    function minimalReset() { 
      const guardEl = document.getElementById('guard')
      const boardEl = document.getElementById('board')
      guardEl.innerHTML = ''
      boardEl.innerHTML = ''
      boardEl.style.position = "fixed";
      
      //SIC
      boardEl.style.width = `${guardEl.clientWidth*0.9}px`;
      boardEl.style.height = `${boardEl.clientWidth}px`;
      

      boardEl.style.left = `${guardEl.offsetLeft + (guardEl.clientWidth-boardEl.clientWidth)/2}px`; 
      boardEl.style.top = `${guardEl.offsetTop + (guardEl.clientHeight)/11 + (guardEl.clientWidth-boardEl.clientWidth)/2}px`;  

      resizingOffset = (guardEl.clientWidth-boardEl.clientWidth)/2
      //document.getElementById('board').style.backgroundColor = 'red';
      if (attackMode) {document.body.style.background =  "#bb4444"}//"#882222"}
      else {document.body.style.background = "#000"}
      const boardWidth = boardEl.clientWidth;
      const boardHeight = boardEl.clientHeight;
      tileSize = boardWidth / size; 
      eeight = tileSize
      eighty = (10/11)*tileSize
      ate = (1/11)*tileSize

      bigScale = (eeight/88)

      weaponWidth = 29 * bigScale
      weaponBuffer = 5 * bigScale
    }
    function drawAll() {
      //eeight = tileSize
      //80 = (10/11)*tileSize
      minimalReset();

      drawBoard();
      drawUpperUI();

      drawOverlay();
      drawTileStack();
      
      drawWeaponStack();
      drawBombStack();
      //drawDebug();
    }

    function drawBoard() {
      //Vestigial function that now only draws the outline of the board.
      const boardEl = document.getElementById('board');
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          const tileEl = document.createElement('div');

          tileEl.style.position = "fixed";
          tileEl.style.left = `${boardEl.offsetLeft + c * eeight}px`;
          tileEl.style.top = `${boardEl.offsetTop + r * eeight}px`;

          // Set the dimensions (square)
          tileEl.style.width = `${eighty}px`;
          tileEl.style.height = `${eighty}px`;
          //tilePhrase= 'bokoTile.png'
          // Set the tile image as the background
          //tileEl.style.backgroundImage = `url('${tile.tile.type.slice(0, 4).toLowerCase()}Tile.png')`;
          tileEl.style.backgroundImage = `url('Animations/Tiles/Blank.png')`;
          tileEl.style.backgroundSize = "100% 100%";  // stretches the image to fill the div
          tileEl.style.backgroundRepeat = "no-repeat";
          // Ensure no extra background color interferes:
          tileEl.style.backgroundColor = "transparent";
          
          boardEl.appendChild(tileEl);
        }
      }
    }

    function drawUpperUI() {
      //Vestigial function that now only draws the outline of the board.
      const guardEl = document.getElementById('guard');

      function scoreShow(fraction,text,color="white",size=1) {
          const textEl = document.createElement('div');
          textEl.style.position = "fixed";

          // Set dimensions (square)
          textEl.style.width = `${400 * bigScale}px`;
          textEl.style.height = `${100 * bigScale}px`;

          // Center it exactly on its own center
          textEl.style.left = `${guardEl.offsetLeft + guardEl.offsetWidth * fraction}px`;
          textEl.style.top = `${guardEl.offsetTop + 5*bigScale}px`;
          textEl.style.transform = "translate(-50%, -50%)"; // Anchor on center

          // Ensure no extra background color interferes:
          textEl.style.backgroundColor = "transparent";

          // Center the text inside
          textEl.style.display = "flex";
          textEl.style.alignItems = "center";
          textEl.style.justifyContent = "center";
          textEl.style.textAlign = "center";
          textEl.style.color = color; // Change text color for visibility
          textEl.style.fontSize = `${18*bigScale*size}px`; // Adjust as needed

          textEl.style.fontFamily = "'BotW',  sans-serif";

          // Add text content
          textEl.textContent = text

          guardEl.appendChild(textEl);
        }
      scoreShow(0.25,`Score: ${score}`)

      if (combo === 0) {comboSize = 1} else {
      // 0 white, 3 yellow, 6 red, 10 dark red
      let color = {0:"#FFFFFF",
        1:"#FFDDAA",
        2:"#FFCC55",
        3:"#FFBB00",
        4:"#FF8800",
        5:"#FF4400",
        6:"#FF0000",
        7:"#DD0044",
        8:"#BB0055",
        9:"#990055",
        10:"#882266",
        }[trueMin(combo,10)]
      scoreShow(0.75,`Killstreak: ${combo}`,color,comboSize)
      comboSize **= 0.99
      }

      //scoreShow(0.75,`Score: ${score} | Combo: ${combo}`)

      function smallText(shift,height,content,actualSize = 12) {
        const hoverEl = document.createElement('div');
      hoverEl.style.position = "fixed";

      // Set dimensions (square)
      hoverEl.style.width = `${400 * realScale}px`;
      hoverEl.style.height = `${100 * realScale}px`;

      // Center it exactly on its own center
      hoverEl.style.left = `${shift}px`;
      hoverEl.style.top = `${height}px`;
      hoverEl.style.transform = "translate(-50%, -50%)"; // Anchor on center

      // Ensure no extra background color interferes:
      hoverEl.style.backgroundColor = "transparent";

      // Center the text inside
      hoverEl.style.display = "flex";
      hoverEl.style.alignItems = "center";
      hoverEl.style.justifyContent = "center";
      hoverEl.style.textAlign = "center";
      hoverEl.style.color = "white"; // Change text color for visibility
      hoverEl.style.fontSize = `${actualSize*realScale}px`; // Adjust as needed

      hoverEl.style.fontFamily = "'BotW',  sans-serif";

      // Add text content
      
        hoverEl.textContent = content
        guardEl.appendChild(hoverEl);
      }
      
      let realScale = guardEl.clientWidth/(88*4)

      if (currentAnimalRow < 0 || currentAnimalColumn < 0) currentAnimal = null

      if (lastDelta > 250) { smallText(guardEl.offsetLeft + guardEl.offsetWidth / 2, guardEl.offsetTop + 30*bigScale + resizingOffset, "Switch to computer to reduce lag") }
      else if (!(attackMode || currentAnimal === null || currentAnimal.health <= 0)) {
        let color = {1:"Red", 2:"Blue", 3:"Black", 4:"Silver", 5:"Golden"}[currentAnimal.level]
        if (currentAnimal.type === "Lizalfo" && color == "Red") color = "Green"
        let text = `${color} ${currentAnimal.type} (${currentAnimal.health}hp/${currentAnimal.maxHealth})`
        if (currentAnimal.thisCombo > 0) {
            if (combo > 0) {
              text = `${text} <this killstreak: ${currentAnimal.thisCombo}hp>`
            } else {
              text = `${text} <last single hit: ${currentAnimal.thisCombo}hp>`
            }
         }
        if (currentAnimal.canHoverTick == 0) smallText(guardEl.offsetLeft + guardEl.offsetWidth / 2, guardEl.offsetTop + 30*bigScale + resizingOffset, text)
    }
    smallText(guardEl.offsetLeft + guardEl.offsetWidth / 4, guardEl.offsetTop-10*bigScale, `High Score: ${localStorage.getItem("highScore")}`)

    if (checkGameOver()) {gameOver = true;}
    if (gameOver) {
      smallText(guardEl.offsetLeft + guardEl.offsetWidth / 2, guardEl.offsetTop+480*realScale, "Game Over!",18)
    }else {
    smallText(guardEl.offsetLeft + guardEl.offsetWidth / 2, guardEl.offsetTop+465*realScale, `Arrow keys / swipe controls to combine matching enemies.`)
    
    if (localStorage.getItem("seenWeapon")) {
      let text = "Tap weapon to use."
      if (localStorage.getItem("seenWeapons")) {
        text = `${text} Tap between two weapons to swap.`
      }
      smallText(guardEl.offsetLeft + guardEl.offsetWidth / 2, guardEl.offsetTop+480*realScale, text)
      if (localStorage.getItem("seenFuse")) {
        smallText(guardEl.offsetLeft + guardEl.offsetWidth / 2, guardEl.offsetTop+495*realScale, `Two matching weapons will combine if adjacent.`)
      }
    }
  }
  }

    function checkGameOver() {
      if (weapons.length > 0 || tileStack.length + weaponStack.length + bombStack.length > 3) {
        return false
      }
      let allPairs = []
      for (let r = 0; r <= 3; r++) {
        for (let c = 0; c <= 3; c++)
        {
          if (grid[r][c] === null) return false
          if (r < 3) allPairs.push([grid[r][c], grid[r+1][c]])
          if (c < 3) allPairs.push([grid[r][c], grid[r][c+1]])
        }
      }
      for (let pair = 0; pair < allPairs.length; pair++) {
        let first = allPairs[pair][0]
        let second = allPairs[pair][1]
        if (first.type === second.type && first.level === second.level) return false
      }
      return true
    }
    function resetCombo() {combo = 0;
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (grid[r][c] != null)
            grid[r][c].thisCombo = 0
        }
      }
    }
    function drawOverlay() {
      const boardEl = document.getElementById('board');
      //Cascading deep delete of everything on the 'board' element, which seems almost like a directory or grouping.
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const tileEl = document.createElement('div');

          tileEl.style.position = "fixed";
          tileEl.style.left = `${boardEl.offsetLeft-(ate/2) + c*eeight}px`; 
          tileEl.style.top = `${boardEl.offsetTop-(ate/2) + r*eeight}px`;  
          
          tileEl.style.width = `${eeight}px`;  // Set square width
          tileEl.style.height = `${eeight}px`;
          // currentAnimalColumn == c && currentAnimalRow == r
          if (targetTiles[r][c]) tileEl.style.background ="rgba(128, 0, 0, 0.5)";
          boardEl.appendChild(tileEl);
        }
      }

    }
    function drawTileStack() {
      const boardEl = document.getElementById('board');

      tileStack[0].forEach(tile => {
        const tileEl = document.createElement('div');

        tileEl.style.position = "fixed";
        tileEl.style.left = `${boardEl.offsetLeft + tile.x + (1 - tile.size) * eighty/2}px`;
        tileEl.style.top = `${boardEl.offsetTop + tile.y + (1 - tile.size) * eighty/2}px`;
        tileEl.style.width = `${tile.size * eighty}px`;
        tileEl.style.height = `${tile.size * eighty}px`;
        tileEl.style.backgroundImage = `url('Animations/Tiles/${tile.tile.type}.png')`;
        tileEl.style.backgroundSize = "100% 100%";
        tileEl.style.backgroundColor = "transparent";

        function animal(alpha, path) {
          const extraImage = document.createElement('div');
          extraImage.style.position = "absolute"
          extraImage.style.left = tileEl.offsetLeft
          extraImage.style.top = tileEl.offsetTop
          extraImage.style.width = "100%";   // Adjust to control scale relative to tileEl
          extraImage.style.height = "100%";

          extraImage.style.backgroundImage = path;
          extraImage.style.backgroundSize = "100% 100%";  // stretches the image to fill the div
          extraImage.style.opacity = `${alpha}`;
          tileEl.appendChild(extraImage);
        }

        let swayFrame = Math.floor(swaySeed / 10) % 4 + 1
        if (swayFrame == 4) swayFrame = 2

        animal(1, `url('Animations/Animals/${tile.tile.type}/${tile.tile.level}/${swayFrame}.png')`)
        
        if (flashSeed > 0 && tile.tile.thisHit > 0) {
          animal(flashSeed/10 * 0.75, `url('Animations/Animal Masks/${tile.tile.type}/${tile.tile.level}/${swayFrame}.png')`)
        }

        function health(numeral, brightness, alpha, path) {
          if (numeral <= 0) {return}
          if (numeral > 20) numeral = 20
          const hBar = document.createElement('div');
          hBar.style.position = "absolute"
          hBar.style.left = tileEl.offsetLeft
          hBar.style.top = tileEl.offsetTop
          hBar.style.width = "100%";   // Adjust to control scale relative to tileEl
          hBar.style.height = "100%";
          hBar.style.filter = `brightness(${brightness}%)`;
          hBar.style.opacity = `${alpha}`;

          hBar.style.backgroundImage = `url('Animations/Hearts/${path}/${numeral}.png')`;
          hBar.style.backgroundSize = "100% 100%";  // stretches the image to fill the div
          hBar.backgroundColor = "transparent";
          tileEl.appendChild(hBar);}
        
          health(20,10,1,"white")

        if (flashSeed > 0 && tile.tile.thisHit > 0) {
          health(20,10,1,"white")

          health(Math.ceil(tile.tile.health/tile.tile.maxHealth * 20),100,flashSeed/10,"red")
          health(Math.ceil((tile.tile.health - tile.tile.thisHit)/tile.tile.maxHealth * 20),100,1,"red")
          health(Math.ceil((tile.tile.health)/tile.tile.maxHealth * 20),100,flashSeed/10,"white")
          health(Math.ceil((tile.tile.health - tile.tile.thisHit)/tile.tile.maxHealth * 20) - 1,100,1,"red")
        } else if (attackMode) {
            if (tile.tile.thisThreat === 0) {
              health(20,10,1,"white")
              if (tile.tile.thisCombo > 0) health(Math.ceil((tile.tile.health+tile.tile.thisCombo)/tile.tile.maxHealth * 20),20,1,"white")
              health(Math.ceil(tile.tile.health/tile.tile.maxHealth * 20),100,100,"red")
            } else {
              //Seems to always think thisThreat = 0
              if (tile.tile.health - tile.tile.thisThreat <= 0) {
                health(1,100,1,"death")
                //Don't show combo here as it's a little over the top.
                //if (tile.tile.thisCombo > 0)  health(Math.ceil((tile.tile.health+tile.tile.thisCombo)/tile.tile.maxHealth * 20),25,(Math.cos(threatLoopSeed/10)**2)/2 + 0.25,"white")
                health(Math.ceil(tile.tile.health/tile.tile.maxHealth * 20),100,(Math.cos(threatLoopSeed/10)**2)/2 + 0.25,"red")
                health(20,0,(Math.cos(threatLoopSeed/10)**2)/2 + 0.25,"white")

              } else {
                health(20,10,1,"white")
                if (tile.tile.thisCombo > 0)  health(Math.ceil((tile.tile.health+tile.tile.thisCombo)/tile.tile.maxHealth * 20),20,1,"white")
                health(Math.ceil(tile.tile.health/tile.tile.maxHealth * 20),100,1,"red")
                health(Math.ceil((tile.tile.health - tile.tile.thisThreat)/tile.tile.maxHealth * 20),100,1,"red")
                health(Math.ceil((tile.tile.health)/tile.tile.maxHealth * 20),0,(Math.cos(threatLoopSeed/20)**2)/4 + 0.5,"white")
                health(Math.ceil((tile.tile.health - tile.tile.thisThreat)/tile.tile.maxHealth * 20) - 1,100,1,"red")
              }
          }
        }
        else {
          health(20,10,1,"white")
          if (tile.tile === currentAnimal && tile.tile.thisCombo > 0) health(Math.ceil((tile.tile.health+tile.tile.thisCombo)/tile.tile.maxHealth * 20),20,1,"white")
          health(Math.ceil(tile.tile.health/tile.tile.maxHealth * 20),100,100,"red")
        }
        
        // Append to the board element
        boardEl.appendChild(tileEl);
        if (tile.tile.canHoverTick > 0) tile.tile.canHoverTick--;
      })
      if (tileStack.length <= 1) {
        tileStack.push(cookBoard())
      }
      tileStack.shift();
      if (appendCooldown > 0) appendCooldown--
      let lostFrames = Math.floor(lastDelta / (1000/60)) - 1 // Number of frames we should have expected in the interim
      for (let frame = 0; frame < lostFrames; frame++) {
        if (tileStack.length > 1) {
          tileStack.shift()
          threatLoopSeed++
        }
        if (appendCooldown > 0) appendCooldown--
      }

      if (appendCooldown === 0) {score += appendToScore; appendToScore = 0; if (score > localStorage.getItem("highScore")) localStorage.setItem("highScore",score)}

      swaySeed += 1 + Math.min(9,lostFrames)

      if (flashSeed == 1) {
        //Increment the combo
        //killQueue = []
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
              if (grid[i][j] !== null && grid[i][j].thisHit > 0){
                //grid[i][j] = {...grid[i][j]}
                grid[i][j].health -= grid[i][j].thisHit
                grid[i][j].thisCombo += grid[i][j].thisHit
                grid[i][j].thisHit = 0
                if (grid[i][j].health <= 0) {
                  score += grid[i][j].maxHealth;
                  if (score > localStorage.getItem("highScore")) localStorage.setItem("highScore",score)
                  killQueue.push(grid[i][j]); grid[i][j] = null
                  //Sic. Always leave a blank frame
                  while(bombStack.length < 38) bombStack.push([])
                  for (let frame = 0; frame <= 37; frame++) bombStack[frame].push(new BombGraphic(j*eeight-(35*bigScale),i*eeight-(15*bigScale),frame))
                  qKills++;
              }
          }
        }
      }
    }
      if (flashSeed == 0) {
        if (killQueue.length > 0) {
        //Quick make sure board is non empty
            tileStack.push(cookBoard())
            let empty = true
            for (let r = 0; r < 4; r++) for (c = 0; c < 4; c++) if (grid[r][c] !== null) empty = false
            if (empty) spawnRandomTile()
            //Iterate through kill queue.
            weaponQueue = []
            for (let kill = 0; kill < killQueue.length; kill++) {
              let buffType = animalsToWeapons[killQueue[kill].type]
              let minimumBuffLevel = killQueue[kill].level
              let lowestRank = trueMin(weapons.filter(weap => weap.type === buffType).map(weap => weap.level))
              //If NO weapons are of the buffType, queue a new one at the beginning.
              if (lowestRank === 0 || lowestRank === 5 || lowestRank === Infinity) {
                if (weapons.length + weaponQueue.length < weaponCap) {
                  weaponQueue.push(new Weapon(buffType,minimumBuffLevel))
                }
              } else { //else
                for (let weap = 0; weap < weapons.length; weap++) {
                  if (weapons[weap].type === buffType && weapons[weap].level === lowestRank) {
                    weapons[weap].level += 1
                    if (weapons[weap].level < minimumBuffLevel) weapons[weap].level = minimumBuffLevel
                    weapons[weap].flash = 60
                    break;
                  }
                }
              }
            }
            introduceQueuedWeapons()
          killQueue = []
        }
      } else {
        flashSeed -= 1
        for (let frame = 0; frame < lostFrames; frame++) {
          if (flashSeed > 1) {
            flashSeed -= 1
          }
        }
      }
      threatLoopSeed++
    }
    
    function drawBombStack() {
      const boardEl = document.getElementById('board');
      bombStack[0].forEach(bomb => {
        const tileEl = document.createElement('div');
        // Position the div as before
        tileEl.style.position = "fixed";
        tileEl.style.left = `${boardEl.offsetLeft + bomb.x}px`;
        tileEl.style.top = `${boardEl.offsetTop + bomb.y}px`;
        // Set the dimensions (square)
        tileEl.style.width = `${150*bigScale}px`;
        tileEl.style.height = `${150*bigScale}px`;
        tileEl.style.backgroundImage = `url('Animations/${bomb.type}/${bomb.frame}.png')`;
        tileEl.style.backgroundSize = "100% 100%";  // stretches the image to fill the div
        tileEl.style.backgroundColor = "transparent";

        // Append to the board element
        boardEl.appendChild(tileEl);
      });
      if (bombStack.length == 1) {
        bombStack.push([])
      } bombStack.shift()
      let lostFrames = Math.floor(lastDelta / (1000/60)) - 1 // Number of frames we should have expected in the interim
      for (let frame = 0; frame < lostFrames; frame++) {
        if (bombStack.length > 1) {
          bombStack.shift()
        }
      }
    }
    let selectionLoopSeed
    let threatLoopSeed = 0 //Handles an oscillating animation for selected weapon.
    let swaySeed = 0
    let flashSeed = 0 //10 means an attack just happened
    // Resets to zero any time nothing is selected or is allowed to be.
    //Also updates weapon selection, which is an instance field in on the weapon itself (NOT its graphic).
    function drawWeaponStack() {
      selectionLoopSeed ++;
      //Board El is used for positioning even though stack El is the one holding the child items.
      const boardEl = document.getElementById('board');
      const stackEl = document.getElementById('stack');
      stackEl.innerHTML = '';
      correctWeaponSelection()
      weaponStack[0].forEach(weap => {
          const weapEl = document.createElement('div');
         
          weapEl.style.position = "fixed";
          
          //We really should have separate code for size modifier. Will add if any problems arise.
          let actualSize = weap.size
          if (weap.weapon.selected == "fire") {
            actualSize *= 1.2
          }
          
            let leftPush = 0
            if (weap.weapon.selected == "merge left") {
              leftPush = -weaponBuffer*(Math.sin(selectionLoopSeed/10) ** 2)
            } else if (weap.weapon.selected == "merge right") {
              leftPush = weaponBuffer*(Math.sin(selectionLoopSeed/10) ** 2)
            } 
            weapEl.style.left = `${boardEl.offsetLeft + weap.x + leftPush + (1-actualSize)*(weaponWidth/2) + (1-weap.shear)*weaponWidth}px`; 
            weapEl.style.top = `${boardEl.offsetTop + eeight * 4 + weap.y + (1-actualSize)*(weaponWidth/2)}px`;  
            weapEl.style.width = `${weaponWidth * actualSize * weap.shear}px`;  // Set square width
            weapEl.style.height = `${weaponWidth * actualSize}px`; // Set square height


          weapEl.style.backgroundImage = `url('Animations/Weapons/${weap.weapon.type}/0.png')`;
          weapEl.style.backgroundSize = "100% 100%";  // stretches the image to fill the div
          //weapEl.style.backgroundRepeat = "no-repeat";
          // Ensure no extra background color interferes:
          weapEl.style.backgroundColor = "transparent";

          function weaponimal(path,opacity=1) {
            const extraImage = document.createElement('div');
            extraImage.style.position = "absolute"
            extraImage.style.left = weapEl.offsetLeft
            extraImage.style.top = weapEl.offsetTop // - 1*bigScale
            extraImage.style.width = "100%";   // Adjust to control scale relative to tileEl
            extraImage.style.height = "100%";

            extraImage.style.backgroundImage = path;
            extraImage.style.backgroundSize = "100% 100%";  // stretches the image to fill the div
            extraImage.style.opacity = opacity
            
            weapEl.appendChild(extraImage);
          }

          stackEl.appendChild(weapEl);
         
          weaponimal(`url('Animations/Weapons/${weap.weapon.type}/${weap.weapon.level}.png')`)
          
          weaponimal(`url('Animations/Threat Backing/${weap.weapon.level}.png')`,Math.sin( weap.weapon.level * Date.now()/1000)**2 / 2 + 0.25)
          weaponimal(`url('Animations/Threat Level/${weap.weapon.level}.png')`)
         
          if (weap.weapon.flash > 0) {
            weaponimal(`url('Animations/Weapons/${weap.weapon.type}/6.png')`,(weap.weapon.flash)/90)

            weap.weapon.flash--

            let lostFrames = Math.floor(lastDelta / (1000/60)) - 1 // Number of frames we should have expected in the interim
              for (let frame = 0; frame < lostFrames; frame++) {
                if (weap.weapon.flash > 0) {
                weap.weapon.flash--
              }
            }
            
          }
          if (weap.weapon === currentWeapon) {
            hoverEl = document.createElement('div');
            hoverEl.style.position = "fixed";

            // Set dimensions (square)
            hoverEl.style.width = `${400 * bigScale}px`;
            hoverEl.style.height = `${100 * bigScale}px`;

            // Center it exactly on its own center
            hoverEl.style.left = `${weapEl.offsetLeft + weapEl.offsetWidth / 2}px`;
            hoverEl.style.top = `${weapEl.offsetTop + weaponWidth + 15*bigScale}px`;
            hoverEl.style.transform = "translate(-50%, -50%)"; // Anchor on center

            // Ensure no extra background color interferes:
            hoverEl.style.backgroundColor = "transparent";

            // Center the text inside
            hoverEl.style.display = "flex";
            hoverEl.style.alignItems = "center";
            hoverEl.style.justifyContent = "center";
            hoverEl.style.textAlign = "center";
            hoverEl.style.color = "white"; // Change text color for visibility
            hoverEl.style.fontSize = `${12*bigScale}px`; // Adjust as needed

            hoverEl.style.fontFamily = "'BotW',  sans-serif";
            hoverEl.textContent = printCurrentWeapon()
            boardEl.appendChild(hoverEl)}
      });
      
      if (weaponStack.length > 1) {
        allowSelectWeapon = false;
        
        weaponStack.shift()
        
        let lostFrames = Math.floor(lastDelta / (1000/60)) - 1 // Number of frames we should have expected in the interim
        for (let frame = 0; frame < lostFrames; frame++) {
          if (weaponStack.length > 1) {
            selectionLoopSeed++ //if lag is sufficient
            weaponStack.shift()
          }
        }
      } else {
        weaponStack.push(cookStack())
        weaponStack.shift()
      }
    }

    function printCurrentWeapon() {
      if (currentWeapon === null) {
        return "bare hands??"
      }
      let currentName = {"1 spear":"Boko Spear",
      "2 spear":"Spiked Boko Spear",
      "3 spear":"Spiked Moblin Spear",
      "4 spear":"Dragonbone Boko Spear",
      "5 spear":"Dragonbone Moblin Spear",

      "1 sword":"Traveler's Sword",
      "2 sword":"Soldier's Broadsword",
      "3 sword":"Knight's Broadsword",
      "4 sword":"Royal Broadsword",
      "5 sword":"Royal Guard's Sword",

      "1 two handed":"Iron Sledgehammer",
      "2 two handed":"Stone Smasher",
      "3 two handed":"Lynel Crusher",
      "4 two handed":"Mighty Lynel Crusher",
      "5 two handed":"Savage Lynel Crusher"}[`${currentWeapon.level} ${currentWeapon.type}`]
      return `${currentName} (${nextSingleHit()}dmg)`
    }
    function drawDebug() {
      const boardEl = document.getElementById('board');
      const dg = document.createElement('div');
      dg.style.position = "absolute"; 
      dg.style.top = `${boardEl.offsetTop + eeight * 4 + weaponWidth + weaponBuffer}px`; 
      dg.textContent = `GLOBAL DEBUG: ${debug}`;
      
      boardEl.appendChild(dg);
    }
    //Cooks and returns a render of the board as reflected in the memory
    //    regardless of any current animations to the contrary
    function cookBoard() {
      let cook = []
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (grid[r][c] != null) {
            let s = 1
            if (r === currentAnimalRow && c === currentAnimalColumn) s = 1.1
            cook.push(new TileGraphic(c*eeight,r*eeight,grid[r][c],s))
          }
        }
      }
      return cook
    }
    function cookStack() {
      let cook = []
      for (let i = 0; i < weapons.length; i++) {
          cook.push(new WeaponGraphic(i*(weaponWidth+weaponBuffer)+(weaponBuffer/2),0,weapons[i]))
        }
      if (weapons.length > 0) {
        localStorage.setItem("seenWeapon",true)
      } if (weapons.length > 1) {
        localStorage.setItem("seenWeapons",true)
      }
      return cook
    }

    function compressAndShift(row) {
      //Returns the new row and all of its shifts
      alreadyMerged = false
      
      let shifts = [0,0,0,0]
      let pulses = [0,0,0,0]
      
      // 1) All tiles go as far to the "left" as they can without hitting any other tile.
      
      for (let i = 0; i < 4; i++) {
        if (row[i] !== null) {
          let j = i
          row[j].canHoverTick = 0
          while (j > 0 && (row[j-1] === null)) {
            row[j].canHoverTick = swellDelay
            shifts[i] += 1
            row[j-1] = row[j]
            row[j] = null
            j -= 1
            alreadyMoved = true
          }
          //row[j-1].type === row[j].type
          if (j > 0 && !alreadyMerged && row[j-1].type === row[j].type &&row[j-1].level === row[j].level) {

            
            row[j].canHoverTick = swellDelay
            shifts[i] += 1
            if (row[j-1].level >= 5) {
              appendToScore += row[j].maxHealth + row[j-1].maxHealth
              appendCooldown = swellDelay
              pulses[j-1] = 2
              killQueue.push(new Tile(row[j-1].type,5,1))
              killQueue.push(new Tile(row[j-1].type,5,1))
              flashSeed = swellDelay
              /*if (weapons.length + weaponQueue.length < weaponCap) weaponQueue.push(new Weapon("spear",5))
              if (weapons.length + weaponQueue.length < weaponCap) weaponQueue.push(new Weapon("sword",5))
              if (weapons.length + weaponQueue.length < weaponCap) weaponQueue.push(new Weapon("two handed",5))*/
              row[j-1] = null
            } else {
              appendToScore += row[j].level + row[j-1].level
              appendCooldown = swellDelay

              row[j-1].canHoverTick = swellDelay
              pulses[j-1] = 1
              if (weapons.length + weaponQueue.length < weaponCap) {
                weaponQueue.push(new Weapon(animalsToWeapons[row[j].type],row[j].level))
              }
              let nextHealth = row[j].health + row[j-1].health
              let nextMax = row[j].maxHealth + row[j-1].maxHealth
              row[j-1] = {...row[j]}
              row[j-1].level += 1
              row[j-1].health = nextHealth
              row[j-1].maxHealth = nextMax
            }
              row[j] = null
              alreadyMerged = true
              alreadyMoved = true
          }
        }
      }
      return [row,shifts,pulses];
    }
    function collapseAndStack() {
      //Also takes care of the animations.
      //Does not bat an eye if some weapons are null.
      let shifts = Array.from({ length: weapons.length }, () => 0)
      let pulses = Array.from({ length: weapons.length }, () => 0)
      
      let oldWeapons = weapons.slice()
      //Simple shift if anything is null
      //Add shifts ONLY
      for (let i = 0; i < weapons.length; i++) {
          if (weapons[i] === null) {
            for (let j = i+1; j < weapons.length; j++) {shifts[j + (shifts.length - weapons.length)] += 1}
            weapons.splice(i,1)
            pulses.splice(i,1)
            pulses.push(0)
          }
      }

      //Simple shifts ONLY
      let anyFuses = true
      singleFuse = false
      while (anyFuses) {
        anyFuses = false;
        for (let i = 0; i < weapons.length - 1; i++) {
          if (weapons[i].type == weapons[i+1].type && weapons[i].level == weapons[i+1].level && weapons[i].level < 5) {
            localStorage.setItem("seenFuse",true)
            for (let j = i+1; j < weapons.length; j++) {shifts[j + (shifts.length - weapons.length)] += 1}
            pulses[i] = 1
            weapons.splice(i+1,1)
            pulses.splice(i+1,1)
            pulses.push(0)
            weapons[i] = {...weapons[i]}
            weapons[i].level += 1
            anyFuses = true;
            singleFuse = true;
            break;
          }
        }
      }

      if (weapons.length < oldWeapons.length) {
        //Intended to be a degenerate no-op
        for (let i = 0; i < 10 + swellDelay; i++) {weaponStack.push([])}
        
        for (let weap = 0; weap < oldWeapons.length; weap++) {
            if (oldWeapons[weap] === null) {continue;}
            for (let i = 0; i < 10; i++) {
              weaponStack[weaponStack.length - 10 - swellDelay + i].push(new WeaponGraphic(
                (weap - shifts[weap]*(i+1)/10)*(weaponWidth+weaponBuffer)+(weaponBuffer/2),0,oldWeapons[weap]
              ))
            }
          }
        for (let weap = 0; weap < weapons.length; weap++) {
            for (let i = 0; i < 10; i++) {
              if (i >= (10 - swellDelay) || pulses[weap] == 1) {
              let s = 1
              if (pulses[weap] == 1) {s += (5 - Math.abs(i - 5))/20}
              weaponStack[weaponStack.length - 10 + i].push(new WeaponGraphic(
                weap*(weaponWidth+weaponBuffer)+(weaponBuffer/2),0,weapons[weap],s)
              )
              }
            }
          }
      }
      weaponStack.push(cookStack())
    }
    let swellDelay = 7
    // Move entire grid to the left
    function moveLeft() {
      tileStack = Array.from({ length: 10 + swellDelay }, () => [])
      for (let r = 0; r < size; r++) {
        // Reverse, merge, reverse back
        const full = compressAndShift(grid[r].slice());

        //Push animation BEFORE updating grid
        for (let c = 0; c < size; c++) {
          if (grid[r][c] != null) {
            for (let i = 0; i < 10; i++) 
              tileStack[i].push(new TileGraphic(c*eeight - (i+1)*(eeight/10)*full[1][c],r*eeight,grid[r][c]))
            }
          }
        
        grid[r] = full[0];
        //Degenerate no op if nothing merges. No worries, as next tile animation will overwrite.
        for (let c = 0; c < size; c++) {
          if (grid[r][c] != null || full[2][c] == 2) {
            for (let i = swellDelay; i < 10+swellDelay; i++) {
              if (i >= 10 || full[2][c] >= 1) {
                let s = 1
                if (full[2][c] == 1) {s += (5 - Math.abs(i - swellDelay - 5))/20}
                if (full[2][c] == 2) {
                  while(bombStack.length < 39 + swellDelay) bombStack.push([])
                  for (let frame = 0; frame <= 38; frame++)
                    bombStack[frame+swellDelay].push(new BombGraphic(c*eeight-(35*bigScale),r*eeight-(15*bigScale),frame, "TK explosion"))
                }
                else tileStack[i].push(new TileGraphic(c*eeight,r*eeight,grid[r][c],s))
              }
            }
          }
        }
      }
      tileStack.push(cookBoard())
      /*

      for (let r = 0; r < size; r++) {
        const newRow = compressAndMerge(grid[r]);
        grid[r] = newRow;
      }
      tileStack.push(cookBoard())*/
    }
    function moveRight() {
      tileStack = Array.from({ length: 10+swellDelay }, () => []);
      for (let r = 0; r < size; r++) {
        // Reverse, merge, reverse back
        const reversed = grid[r].slice().reverse();
        const full = compressAndShift(reversed);

        //Push animation BEFORE updating grid
        for (let c = 0; c < size; c++) {
          if (grid[r][c] != null) {
            for (let i = 0; i < 10; i++) {
              //For some reason, we seem to have changed the value on the grid, without even 
             tileStack[i].push(new TileGraphic(c*eeight + (i+1)*(eeight/10)*full[1][3-c],r*eeight,grid[r][c]))
             //tileStack[i].push(new TileGraphic(c*eeight + (i+1)*8.8*full[1][3-c],r*eeight,new Tile("bord", full[0].reverse())))
            }
          }
        }
        grid[r] = full[0].reverse(); 
        for (let c = 0; c < size; c++) {
          if (grid[r][c] != null || full[2][3-c] == 2) {
            for (let i = swellDelay; i < swellDelay + 10; i++) {
              if (i >= 10 || full[2][3-c] >= 1) {
                let s = 1
                if (full[2][3-c] == 1) {s += (5 - Math.abs(i - swellDelay - 5))/20}
                if (full[2][3-c] == 2) {
                  while(bombStack.length < 39 + swellDelay) bombStack.push([])
                  for (let frame = 0; frame <= 38; frame++)
                    bombStack[frame+swellDelay].push(new BombGraphic(c*eeight-(35*bigScale),r*eeight-(15*bigScale),frame, "TK explosion"))
                }
                else tileStack[i].push(new TileGraphic(c*eeight,r*eeight,grid[r][c],s))
              }
            }
          }
        }
      }
      //tileStack.push(cookBoard())

      tileStack.push(cookBoard())
    }
    function moveUp() {
      tileStack = Array.from({ length: 10+swellDelay }, () => []);
      for (let c = 0; c < size; c++) {
        // Build a column array
        let col = [];
        for (let r = 0; r < size; r++) {
          col.push(grid[r][c]);
        }
        // Merge
        //col = compressAndMerge(col);
        const full = compressAndShift(col);

        //Push animation BEFORE updating grid
        for (let r = 0; r < size; r++) {
          if (grid[r][c] != null) {
            for (let i = 0; i < 10; i++) {
              tileStack[i].push(new TileGraphic(c*eeight, r*eeight-(i+1)*(eeight/10)*full[1][r],grid[r][c]))
            }
          }
        }

        // Assign back
        for (let r = 0; r < size; r++) {
          grid[r][c] = full[0][r];
        }

        for (let r = 0; r < size; r++) {
          if (grid[r][c] != null || full[2][r] == 2) {
            for (let i = swellDelay; i < swellDelay + 10; i++) {
              if (i >= 10 || full[2][r] >= 1) {
                let s = 1
                if (full[2][r] == 1) {s += (5 - Math.abs(i - swellDelay - 5))/20}
                if (full[2][r] == 2) {
                  while(bombStack.length < 39 + swellDelay) bombStack.push([])
                  for (let frame = 0; frame <= 38; frame++)
                    bombStack[frame+swellDelay].push(new BombGraphic(c*eeight-(35*bigScale),r*eeight-(15*bigScale),frame, "TK explosion"))
                }
                else tileStack[i].push(new TileGraphic(c*eeight,r*eeight,grid[r][c],s))
              }
            }
          }
        }
      } 
      tileStack.push(cookBoard())
    }
    function moveDown() {
      tileStack = Array.from({ length: 10+swellDelay }, () => []);
      for (let c = 0; c < size; c++) {
        // Build a column array
        let col = [];
        for (let r = 0; r < size; r++) {
          col.push(grid[r][c]);
        }
        // Merge
        //col = compressAndMerge(col);
        const full = compressAndShift(col.reverse());

        
        //Push animation BEFORE updating grid
        for (let r = 0; r < size; r++) {
          if (grid[r][c] != null) {
            for (let i = 0; i < 10; i++) {
              tileStack[i].push(new TileGraphic(c*eeight, r*eeight+(i+1)*(eeight/10)*full[1][3-r],grid[r][c]))
            }
          }
        }

        // Assign back
        for (let r = 0; r < size; r++) {
          grid[r][c] = full[0][3-r];
        }
        for (let r = 0; r < size; r++) {
          if (grid[r][c] != null || full[2][3-r] == 2) {
            for (let i = swellDelay; i < swellDelay+10; i++) {
              if (i >= 10 || full[2][3-r] >= 1) {
                let s = 1
                if (full[2][3-r] == 1) {s += (5 - Math.abs(i - swellDelay - 5))/20}
                if (full[2][3-r] == 2) {
                  while(bombStack.length < 39 + swellDelay) bombStack.push([])
                  for (let frame = 0; frame <= 38; frame++)
                    bombStack[frame+swellDelay].push(new BombGraphic(c*eeight-(35*bigScale),r*eeight-(15*bigScale),frame, "TK explosion"))
                }
                else tileStack[i].push(new TileGraphic(c*eeight,r*eeight,grid[r][c],s))
              }
            }
          }
        }
      }
      tileStack.push(cookBoard())
    }

    let alreadyMerged = false
    let alreadyMoved = false
    let singleFuse = false
    let weaponQueue = []
    let killQueue = []
    // Handle arrow key presses
    function handleKey(e) {
      if (attackMode){
        attackMode = false;
        handleSwipe(e);
      }
      handleKeyString(e.key)
      //DELETE THIS
    }

    function handleKeyString(st) {
      alreadyMerged = false;
      alreadyMoved = false;
      if (tileStack.length > 15) {return}
      switch (st) {
        case 'ArrowLeft':
          moveLeft();
          break;
        case 'ArrowRight':
          moveRight();
          break;
        case 'ArrowUp':
          moveUp();
          break;
        case 'ArrowDown':
          moveDown();
          break;
      }
      if (alreadyMoved) {
        if (currentAnimalColumn >= 0 && currentAnimalRow >= 0){
          currentAnimal = grid[currentAnimalRow][currentAnimalColumn]
        }
        resetCombo();
        introduceQueuedWeapons();
        spawnRandomTile();
      }
    }

    function nextSingleHit(weapon) {
      let baseDamage = 1
      for (let i = 1; i < currentWeapon.level; i++)
        {baseDamage *= 2; baseDamage += 1}
      return baseDamage
    }
    function introduceQueuedWeapons() {
    let lastWeapon = null
        while (weaponQueue.length > 0) {
          //weaponQueue.shift()
          if (weapons.length > 0) {
            lastWeapon = weapons[weapons.length - 1]
          }
          let pushOccured = false
          for (let i = 0; i < weaponQueue.length; i++) {
            //Replace with code actually checking whether the two are fusable
            if (lastWeapon !== null && weaponQueue[i].type === lastWeapon.type) {
              weapons.push(weaponQueue.splice(i,1)[0])
              pushOccured = true
            }
          }
          if (!pushOccured) {weapons.push(weaponQueue.shift())}
          //Pushes a new weapon graphic to enter from the right
          //starting on the EXACT FRAME that the tiles would start swelling.
          while (weaponStack.length < 10 + swellDelay) {
            weaponStack.push(weaponStack[weaponStack.length - 1].slice())
          }
          for (let frame = 0; frame < 10; frame++) {
            weaponStack[weaponStack.length - 10 + frame].push(
              new WeaponGraphic((9 - (10 - weapons.length)*frame/10)*(weaponWidth+weaponBuffer)+(weaponBuffer/2),0,
              weapons[weapons.length - 1],
              1,(frame+1)/10)
            )
          }
        
  }
  collapseAndStack()
}
    function handleClick(e) {
     if(!attackMode) {
      if (currentWeapon !== null) {
        currentAnimalRow = -1
        currentAnimalColumn = -1
        currentAnimal = null
        attackMode = true
        allowSelectWeapon = false
        correctThreatCalculation()
      }
     } else {
      if (mouseRow == -1) {
        attackMode = false
        allowSelectWeapon = true
        threatLoopSeed = 0
        //Force hard cancel on clickaway
        //EXPOSED if: you can never swap, but everything looks beautiful, even when an enemy is hurt or killed.
        //Or sometimes it doesn't
        if (!allowHover) {for (let i = 0; i < weapons.length; i++)  weapons[i].selected = false}
      } else {
        let anyKills = false;
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            if (targetTiles[i][j]) {
              if (grid[i][j] !== null){
                //TODO: Actually deal damage according to the weapon level
                //Accumulate this damage to this hit and this combo
                flashSeed = 10
                //grid[i][j] = {...grid[i][j]}
                let damage = nextSingleHit()
                //damage = 5
                //In theory, health cannot go negative
                if (grid[i][j].health - (damage + grid[i][j].thisHit) <= 0) {
                  anyKills = true
                  damage = grid[i][j].health - grid[i][j].thisHit
                }
                grid[i][j].thisHit += damage
                score += damage * (combo+1)
                if (score > localStorage.getItem("highScore")) localStorage.setItem("highScore",score)
              }
            }
          }
        }
        if (anyKills) {combo++; qKillTurns++; comboSize += combo/10} else resetCombo()
        weapons[currentIndex] = null
        collapseAndStack();
        
      }
      attackMode = false
      allowSelectWeapon = true
     }
     let lambdaHover = allowHover
     allowHover = true;
     handleSwipe(e)
     allowHover = lambdaHover
     //Attempt swap
      if (mouseRow === 4) {
        for (let i = 0; i < weapons.length - 1; i++) {
          if (weapons[i].selected === "merge right") {
            weaponStack = Array.from({ length: 10 }, () => []);
            for (let otherWeapon = 0; otherWeapon < weapons.length; otherWeapon++) {
              for (let frame = 0; frame < 10; frame++) {
                let leftPush = 0
                if (weapons[otherWeapon].selected === "merge right") {leftPush = (frame+1)/10 * (weaponWidth+weaponBuffer)}
                if (weapons[otherWeapon].selected === "merge left") {leftPush = (frame+1)/(-10) * (weaponWidth+weaponBuffer)}
                weaponStack[frame].push(new WeaponGraphic(leftPush + otherWeapon*(weaponWidth+weaponBuffer)+(weaponBuffer/2),0,weapons[otherWeapon]))
              }
            }
            [weapons[i], weapons[i+1]] = [weapons[i+1],weapons[i]]
            collapseAndStack();
            break;
          } 
        }
      }  
    }
    
    //Called immediately when a swipe is let go of, in case you drag out of the screen.

    //NO op if the click is on a weapon -- those are handle already
    function handleHighClick(event) {
      const boardRect = boardEl.getBoundingClientRect(); // Get board position
      // Calculate relative position
      relativeX = event.clientX - boardRect.left;
      relativeY = event.clientY - boardRect.top;
      
      if (relativeY <= eeight*4) {
          handleClick(event)
        }
    }
    function handleSwipe(event) {
      targetTiles = [[false,false,false,false],[false,false,false,false],[false,false,false,false],[false,false,false,false]]
      currentAnimalRow = -1
      currentAnimalColumn = -1
      const boardRect = boardEl.getBoundingClientRect(); // Get board position
      // Calculate relative position
      relativeX = event.clientX - boardRect.left;
      relativeY = event.clientY - boardRect.top;

      //Also if weapons are being animated, do this as well

      let anyMerges = false
      if (!attackMode) {currentWeapon = null; for (let i = 0; i < weapons.length; i++) {
        if (weapons[i].selected == "merge right") {
          anyMerges = true
        }
        weapons[i].selected = false
      }; allowSelectWeapon = true}

      if (!anyMerges) selectionLoopSeed = 0

      if (allowSelectWeapon && relativeY > eeight*4 + weaponWidth + (weaponBuffer/2)) {
        //This only throws immediately if weapon selection is allowed.
        mouseRow = -1
      } else if (allowSelectWeapon && relativeY > eeight*4 && (relativeX < 0 || relativeX > (eeight*4)-ate) ) {
        mouseRow = -1
      } else if (allowSelectWeapon && relativeY > eeight*4 - (weaponBuffer/2)) {
        mouseRow = 4
        mouseCol = (relativeX - (weaponWidth + weaponBuffer)/2) / (weaponWidth + weaponBuffer)
        if (mouseCol < 0) {mouseCol = 0}
        if (mouseCol > weaponCap - 1) {mouseCol = weaponCap - 1}
      } else { 
        if (trueMin(relativeX, relativeY) < -eeight/2 || Math.max(relativeX, relativeY) > eeight*4.5 || attackMode && relativeY > eeight*4) {
          mouseRow = -1
          correctThreatCalculation()
        } else {
          mouseRow = (relativeY - (eighty/2)) / eeight
          mouseCol = (relativeX - (eighty/2)) / eeight
          
          if (attackMode) {
            if ("spear" === currentWeapon.type) {
              //Vertical select
              if (Math.abs(1.5-mouseRow) > Math.abs(1.5-mouseCol)){
                for (let i = 0; i < 4; i++)
                  targetTiles[i][Math.round(mouseCol)] = true
              } else {
                targetTiles[Math.round(mouseRow)] = [true, true, true, true]
              }
            } else if ("sword" === currentWeapon.type) {
              //Vertical select
              let row = Math.max(1,trueMin(Math.round(mouseRow),3))
              let col = Math.max(1,trueMin(Math.round(mouseCol),3))
              targetTiles[row-1][col-1] = true
              targetTiles[row-1][col] = true
              targetTiles[row][col-1] = true
              targetTiles[row][col] = true
            } else if ("two handed" === currentWeapon.type) {
              //Vertical select
              let row = Math.max(0,trueMin(Math.round(mouseRow),3))
              let col = Math.max(0,trueMin(Math.round(mouseCol),3))
              targetTiles[row][col] = true
              if (row > 0) targetTiles[row-1][col] = true
              if (row < 3) targetTiles[row+1][col] = true
              if (col > 0) targetTiles[row][col-1] = true
              if (col < 3) targetTiles[row][col+1] = true
            }
            correctThreatCalculation()
          } else if (!((trueMin(relativeX, relativeY) <  0 || Math.max(relativeX, relativeY) > eeight*4))) {currentAnimalRow = Math.max(0,trueMin(Math.round(mouseRow),3));
            currentAnimalColumn = Math.max(0,trueMin(Math.round(mouseCol),3))
          currentAnimal = grid[currentAnimalRow][currentAnimalColumn]}
        }
      
    } correctWeaponSelection();
  }
    function correctThreatCalculation() {
    let damage = nextSingleHit()
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
          if (grid[i][j] !== null) {
            if (targetTiles[i][j]) {grid[i][j].thisThreat = damage} else {grid[i][j].thisThreat = 0}
          }
      }
    }
  }
    function correctWeaponSelection() {
      if (weapons.length > 0 && weapons[weapons.length-1].selected === "merge right") {weapons[weapons.length-1].selected = false}
      for (let i = 0; i < weapons.length; i++) {
        if (mouseRow === 4 && allowHover) {
          //fire weapon
          if (mouseCol > i - 0.5 && mouseCol <= i - 0.25) {weapons[i].selected = "merge left"; weapons[i-1].selected = "merge right"}
          else if (mouseCol > i - 0.25 && mouseCol <= i + 0.25) {weapons[i].selected = "fire"; currentIndex = i; currentWeapon = weapons[i]}
          else if (mouseCol > i + 0.25 && mouseCol <= i + 0.5 && i < weapons.length - 1)
            {weapons[i].selected = "merge right"; weapons[i+1].selected = "merge left"}
        } else {
          if (!(attackMode && weapons[i].selected == "fire")) {weapons[i].selected = false}
        }
      }
    }

    const boardEl = document.getElementById('board'); // Ensure the board element exists

    let relativeX
    let relativeY
    let mouseRow
    let mouseCol
    //If for some reason you like to click outside of the grid when doing spear attacks or smth
    let allowSelectWeapon = true
    document.addEventListener("pointermove", (_) => { allowHover = true; });
    document.addEventListener("mousemove", (event) => { 
    //Any fleeting mouse movement is trea
    let lambdaHover = allowHover;
    allowHover = true;
    handleSwipe(event); allowHover = lambdaHover})
    window.addEventListener('keydown', handleKey);

    let mouseDownDetected = false;
    document.addEventListener("touchmove", (event) => {event.preventDefault(); allowHover = true; handleSwipe(event.touches[0])}, { passive: false });

    //allowHover is whether we can safely assume that the mouse is there even when it is released.
    //True on touch down, or mousemove.
    //False on touch release.
    let startX = 0, startY = 0, startTime = 0; allowHover = true;
        //let isTouch = false; // Tracks if we're in touch mode

        function startTracking(x, y) {
            startX = x;
            startY = y;
            startTime = Date.now();
        }

        function endTracking(x, y) {
            const deltaX = x - startX;
            const deltaY = y - startY;
            const elapsedTime = Date.now() - startTime;

            const minDistance = 50;  // Minimum swipe distance in pixels
            const maxDuration = 300; // Max time in ms for it to be considered a swipe

            if (elapsedTime > maxDuration) return; // Too slow, ignore

            if (Math.abs(deltaX) > minDistance || Math.abs(deltaY) > minDistance) {
                // Determine closest cardinal direction
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    deltaX > 0 ? onSwipeRight() : onSwipeLeft();
                } else {
                    deltaY > 0 ? onSwipeDown() : onSwipeUp();
                }
            }
        }

        const overlay = document.getElementById("swipeOverlay")

        overlay.addEventListener("touchstart", (event) => {
            allowHover = true;
            startTracking(event.touches[0].clientX, event.touches[0].clientY);
            handleSwipe(event.touches[0]);
        });

        overlay.addEventListener("touchend", (event) => {
            //Cannot treat every low touch as a click or else we double count selecting a weapon at the bottom... and don't even think about swap operations
            handleHighClick(event.changedTouches[0])
            endTracking(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
            allowHover = false;
        });

        // Mouse events (for desktop support).
        // Tapping simulates an immediate mousemove and mousedown, whether you want it to or not.
        document.addEventListener("mousedown", (event) => {
          if (!mouseDownDetected) {handleClick(event);}; mouseDownDetected = true;
            startTracking(event.clientX, event.clientY);
        });

        document.addEventListener("mouseup", (event) => {
            mouseDownDetected = false;
            endTracking(event.clientX, event.clientY);
        });

        // Swipe handlers
        function onSwipeLeft()  { handleKeyString("ArrowLeft") }
        function onSwipeRight() { handleKeyString("ArrowRight") }
        function onSwipeUp()    { handleKeyString("ArrowUp") }
        function onSwipeDown()  { handleKeyString("ArrowDown") }

    init();
  </script>
</body>
</html>